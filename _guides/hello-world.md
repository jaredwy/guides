---
layout: guide
title: The Neon Project - Hello, World!
nav-title: Hello, World!
nav-order: 1
---

# Hello, World!

This guide will walk you through writing, building, and running your first Neon project. We'll try to walk you through each step carefully, but if you want to skip ahead, you can always go straight to the [full demo](.) in the examples repository.

Our first project will be a tiny module that returns a number indicating how much hardware multithreading the current machine supports. If you're not familiar with multithreading, don't panic! We'll be using [Sean McArthur](http://seanmonstar.com/)'s [num_cpus](https://crates.io/crates/num_cpus) library to do all the heavy lifting for us, and we'll just return the number it gives us.

But even this simple example already demonstrates some of Neon's usefulness: Rust's [crate ecosystem](https://crates.io/) is younger than npm but growing quickly and already full of useful and unique libraries. A library like `num_cpus` could be useful, for example, as a hint for tuning the size of a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) pool in an [Electron app](../electron-apps/).

# Creating a New Project

The first thing we have to do is create our new `threading-hint` Neon project:

```shell
$ neon new threading-hint
```

This will ask us a series of questions similar to the ones asked by `npm new`. When it completes, the tool will have created a `threading-hint` directory with the following layout:

```text
threading-hint/
├── .gitignore
├── README.md
├── lib/
│   └── index.js
├── native/
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
└── package.json
```

The first thing to notice about this layout is that **a Neon project is a Node package**. In other words, the way to think of a Neon project is:

> Node on the outside, Rust on the inside.

# Building and Running

We haven't yet implemented anything, but just to see that `neon new` produced a complete, minimal Neon project, let's try building and running it.

```shell
$ neon build
# build output...
$ node
> require('.')
hello node
{}
```

# Adding a Rust dependency

The next thing to notice about our `threading-hint` project layout is that the Rust implementation lives in the `native/` subdirectory. This is where the `Cargo.toml` manifest file for your Rust code lives. Let's add a Rust dependency on the [num_cpus](https://crates.io/crates/num_cpus) crate ("crate" is just Rust terminology for a package). In `native/Cargo.toml`, under the `[dependencies]` section, add the following line:

```toml
num_cpus = "1.4.0"
```

This adds a dependency on any version of the `num_cpus` crate that is semver-compatible with `1.4.0`. (The `package.json` equivalent would be `"num_cpus": "^1.4.0"`.)

# Implementing our Function

Now let's edit the Rust code to make use of the new dependency. First we have to declare the use of the the `num_cpus` crate:

```rust
extern crate num_cpus;
```

Next we can replace the sample `hello` function that was generated by `neon new` with the function we actually want. Instead of returning a string, our function should return a JavaScript number. So we'll use the [`JsNumber::new()`](https://api.neon-bindings.com/neon/js/struct.jsnumber#method.new) API. Since `JsNumber` expects a Rust [`f64`](https://doc.rust-lang.org/std/primitive.f64.html) (i.e., a 64-bit floating-point number), and [`num_cpus::get()`](https://docs.rs/num_cpus/1.4.0/num_cpus/fn.get.html) returns a [`usize`](https://doc.rust-lang.org/std/primitive.usize.html) (i.e., a pointer-sized integer), we'll use Rust's `as` operator to cast to convert the integer to floating-point:

```rust
use neon::js::JsNumber;

fn threading_hint(call: Call) -> JsResult<JsNumber> {
    Ok(JsNumber::new(call.scope, num_cpus::get() as f64))
}
```

A few more things to note about this code:

  * The `call` argument to `threading_hint`: this contains metadata about the live JavaScript function call every time this function is called.
  * The [`JsResult`](https://api.neon-bindings.com/neon/vm/type.jsresult) output type: this is a Rust [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html) type that indicates whether the function returned (`Ok`) or threw a JavaScript exception (`Err`). You can learn more in the [Handling Errors](../handling-errors) guide. It also tracks the lifetime of the returned _handle_. You can read more about handles in the [Handles and Memory](../handles-and-memory/) guide.
  * The `call.scope` argument to `JsNumber::new()`. This ensures that the number we allocate will kept alive (i.e., not garbage-collected) for the duration of the `threading_hint` function call. You can learn more about handles in the [Handles and Memory](../handles-and-memory/) guide.

Finally, we'll modify the code that `neon new` created for us to set up the module exports with this function instead of the initial "hello world" function it created for us:

```rust
register_module!(m, {
    m.export("threading_hint", threading_hint)
});
```

This tells Neon to initialize the module when it's first loaded by creating a JavaScript function implemented with the `threading_hint` function we defined above and exporting it as a module property named `"threading_hint"`.

You can see the full [`lib.rs`](.) file in the examples repository.

# Exporting our Function

Now that the Rust code is implemented, all we have left to do is export it from the project's public module. The native module exported a `threading_hint` property, so we'll just make that function our entire public module:

```js
var addon = require('../native');

module.exports = addon.threading_hint;
```

# Try it Out!

Now we should be able to rebuild the project with `neon build` again:

```shell
$ neon build
```

Assuming we didn't make any mistakes, we can test out our new Neon module at the Node console:

```shell
$ node
> var threadingHint = require('.')
> threadingHint()
4
```

Keep in mind that the result of calling `threadingHint()` will vary based on the machine you run this demo on—by design!
